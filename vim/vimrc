" Init
" ------------------------------------------------------------------------------
set encoding=utf-8
scriptencoding utf-8

if !1 | finish | endif
if !&compatible | set nocompatible | endif

" viminfoの場所
if isdirectory(expand('~/.vim'))
    set viminfo+=n~/.vim/viminfo
endif



" Basic
" ------------------------------------------------------------------------------
set noswapfile                        " スワップファイルを作成しない
set nobackup                          " バックアップを作成しない
set noundofile                        " undoファイルを作成しない
set backspace=indent,eol,start        " <BS>が削除する位置（インデント、行末、改行マタギ）
set list                              " 特殊文字を表示
set listchars=tab:>-,trail:-          " 特殊文字のキャラクタ
set virtualedit=block                 " 自由な矩形選択
set expandtab                         " <Tab>をスペースに展開
set tabstop=4 shiftwidth=4            " <Tab>スペース展開文字幅
set shiftround                        " インデントをshiftwidthに丸める
set smarttab                          " 自動インデント
set autoindent                        " 改行後の自動インデント
if (v:version == 704 && has('patch338')) || v:version >= 705
    set breakindent                   " 折り返した行がインデントに沿う
endif
set synmaxcol=300                     " 1行あたりのシンタックス有効文字数
set number                            " 行番号
set scrolloff=10                      " バッファスクロール時に上下10行を確保
set showmatch                         " 対応するカッコをハイライト
set matchtime=1                       " カッコ間移動時間
set display=lastline                  " 行が長くても表示
set splitright                        " 分割バッファを右に開く
set hidden                            " ファイルを保存しなくても新しいバッファを開く
set laststatus=2                      " ステータスラインを常に表示
set ruler                             " ステータスラインに現在行情報を表示
set showcmd                           " ステータスライン下に入力中コマンドを表示
set noshowmode                        " モードを表示しない
set cmdheight=2                       " コマンドラインの高さ
set wildmenu                          " コマンドライン補完
set wildignorecase                    " コマンドライン補完を大文字・小文字無視
set incsearch                         " インクリメンタルサーチ
set hlsearch                          " マッチ文字列をハイライト
set nowrapscan                        " 最後まで検索したら、最初のマッチ文字列に移動しない
set ignorecase                        " 検索文字列で大文字・小文字を区別しない
set smartcase                         " 検索文字列で大文字が混在している場合は区別する
set modeline                          " モードラインを有効
set modelines=5                       " モードラインを上下5行まで検索
set infercase                         " 補完時に大文字・小文字を区別しない
set textwidth=0                       " 行あたりの最大文字数？を0に（formatoptions）
set tags+=.git/tags                   " .gitにあるタグファイルも読む
set ttimeoutlen=10                    " キーシーケンス終了の待ち時間を短く



" Remap
" ------------------------------------------------------------------------------
nnoremap <Space> :
vnoremap <Space> :

" Yの挙動をC, Dと揃える
nnoremap Y y$

" 一文字削除は削除レジスタを使用
nnoremap x "_x
vnoremap x "_x

" かっこ
inoremap '' ''<C-G>U<Left>
inoremap "" ""<C-G>U<Left>
inoremap () ()<C-G>U<Left>
inoremap {} {}<C-G>U<Left>
inoremap [] []<C-G>U<Left>
inoremap <> <><C-G>U<Left>

" search
nnoremap <silent><Esc><Esc> :<C-u>nohlsearch<CR>
nnoremap n nzz
nnoremap N Nzz

" 挿入モード時のカーソル移動
inoremap <C-b> <C-G>U<Left>
inoremap <C-f> <C-G>U<Right>
inoremap <C-a> <C-G>U<Home>
inoremap <C-e> <C-G>U<End>
inoremap <C-k> <C-G>U<C-o>D

" visual mode
vnoremap v $h

" コマンドモード時のカーソル移動
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-k> <C-\>e getcmdpos() == 1 ? '' : getcmdline()[:getcmdpos()-2]<CR>

" ノーマルモード時に<CR>で改行
nnoremap <CR> o<esc>

" バッファ操作
nnoremap <silent><Space>vs :<C-u>vsp<CR>
nnoremap <silent><Space>sp :<C-u>sp<CR>
nnoremap <silent><Space>vn :<C-u>vnew<CR>
nnoremap <silent><Space>st :<C-u>tabnew<CR>
nnoremap <silent><Left> <C-w><
nnoremap <silent><Right> <C-w>>
nnoremap <silent><Tab> <C-w>w

" toggle relative line number and column highlight
nnoremap <silent><F3> :<C-u>setlocal relativenumber!<CR>
nnoremap <silent><F1> :<C-u><C-\>e'setlocal colorcolumn='.(&colorcolumn ? '' : '120')<CR><CR>
nnoremap <silent><leader>c :<C-u>setlocal cursorcolumn!<CR>

" help
nnoremap <C-h> :h<Space>

" echo file path
nnoremap <C-g> 1<C-g>

" <C-w>oを上書き
command! Big wincmd _ | wincmd |
nnoremap <silent><C-w>o :<C-u>Big<CR>

" 0と^を入れ替え
nnoremap 0 ^
nnoremap ^ 0

" *しても次の候補へ移動しないように
nnoremap * "zyiw:let @/ = @z<CR>:<C-u>set hlsearch<CR>

" ビジュアルモードで選択中のテキストを検索
vnoremap * "zy:let @/ = @z<CR>:<C-u>set hlsearch<CR>

" cしたときの元テキスト格納先レジスタを削除レジスタへ変更
vnoremap c "_c

" 縦分割でタグジャンプ
nnoremap <C-]> :vsp<CR> :exe("tjump ".expand('<cword>'))<CR>

" 行を移動
map K <nop>
vnoremap K "zx<UP>"zP`[V`]
vnoremap J "zx"zp`[V`]



" File type
" ------------------------------------------------------------------------------
augroup my_filetype
    autocmd!
    autocmd FileType help nnoremap <silent><buffer>q :quit<CR>
    autocmd FileType help wincmd L
    autocmd FileType html,css,less,scss,ruby,yaml,javascript setlocal tabstop=2 shiftwidth=2
    autocmd FileType php setlocal noexpandtab tabstop=4 shiftwidth=4
    autocmd FileType html inoremap <buffer></ </<C-x><C-o>
    autocmd FileType markdown hi! def link markdownItalic Normal
    autocmd BufNewFile,BufRead *.{md,mdwn,mkd,mkdn} setlocal filetype=markdown
augroup END



" Statusline
" ------------------------------------------------------------------------------
set statusline =\ %F\ \|\ %{&modified?'+\ \|':&modifiable?'':'-\ \|'}
set statusline+=%=\|\ %{(&fenc!=''?&fenc:&enc).':'.&ff}\ \|\ %{&filetype!=''?&filetype:'no\ ft'}\ \|\ %l:%c\ 



" Other
" ------------------------------------------------------------------------------
" Use vsplit mode (?)
" http://qiita.com/kefir_/items/c725731d33de4d8fb096
if has("vim_starting") && !has('gui_running') && has('vertsplit')
    function! g:EnableVsplitMode()
        " enable origin mode and left/right margins
        let &t_CS = "y"
        let &t_ti = &t_ti . "\e[?6;69h"
        let &t_te = "\e[?6;69l\e[999H" . &t_te
        let &t_CV = "\e[%i%p1%d;%p2%ds"
        call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
    endfunction

    " old vim does not ignore CPR
    map <special> <Esc>[3;9R <Nop>

    " new vim can't handle CPR with direct mapping
    " map <expr> ^[[3;3R g:EnableVsplitMode()
    set t_F9=[3;3R
    map <expr> <t_F9> g:EnableVsplitMode()
    let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

" 管理者権限で書き込み
if executable('sudo') && executable('tee')
    cnoremap w!! %!sudo tee > /dev/null %
endif

" Vimスクリプトの行継続のインデント幅
let g:vim_indent_cont = 4

" 挿入モードのクソみたいな挙動を切る
augroup no_comment
    autocmd!
    autocmd BufEnter * setlocal fo-=r
    autocmd BufEnter * setlocal fo-=o
    autocmd BufEnter * setlocal fo-=c
    autocmd BufEnter * setlocal fo-=t
    autocmd BufEnter * setlocal fo-=q
augroup END

" 全てのマッピングを表示
command! -nargs=* -complete=mapping AllMaps map <args> | map! <args> | lamp <args>

" 現在行ハイライトをカレントバッファのみに適用
augroup highlight_cursorline_on_current_buffer
    autocmd!
    autocmd BufLeave,WinLeave * setlocal nocursorline
    autocmd BufEnter,WinEnter * setlocal cursorline
augroup END

" カーソル行ハイライト時の特殊文字の色
augroup special_key_highlight
    autocmd!
    autocmd VimEnter,WinEnter * match NonText '^\s\+'
augroup END

" 外部でファイルが変更された場合（かつ、編集していない場合）は自動でリロードする
set autoread
augroup checktime
    autocmd!
    autocmd WinEnter * checktime
augroup END

" 挿入モードを抜けた際、強制的にペーストモードを解除する
augroup leave_paste_mode_auto
    autocmd!
    autocmd InsertLeave * set nopaste
augroup END



" NeoBundle wrap functions
" ------------------------------------------------------------------------------
function! s:bundle_tap(bundle)
    return exists('*neobundle#tap') && neobundle#tap(a:bundle)
endfunction

function! s:bundle_end()
    try
        call neobundle#untap()
        call neobundle#end()
        filetype plugin indent on
        NeoBundleCheck
        if !has('vim_starting')
            call neobundle#call_hook('on_source')
        endif
    catch
    endtry
endfunction



" Load plugins list
" ------------------------------------------------------------------------------
if isdirectory(expand('~/.vim/bundle/neobundle.vim'))
    if has('vim_starting')
        set rtp+=~/.vim/bundle/neobundle.vim/
    endif
    call neobundle#begin(expand('~/.vim/bundle/'))

    NeoBundleFetch 'Shougo/neobundle.vim'

    " base
        NeoBundle     'Shougo/vimproc.vim'
        NeoBundle     'vim-jp/vimdoc-ja'

    " looks
        if !filereadable(expand('~/.vim/disable_devicon'))
            NeoBundle 'ryanoasis/vim-devicons'
        endif
        NeoBundle     'altercation/vim-colors-solarized'
        NeoBundle     'atelierbram/vim-colors_duotones'
        NeoBundle     'cocopon/iceberg.vim'
        NeoBundle     'morhetz/gruvbox'
        NeoBundle     'tomasr/molokai'
        NeoBundle     'NLKNguyen/papercolor-theme'
        NeoBundle     'w0ng/vim-hybrid'
        NeoBundle     'itchyny/lightline.vim'
        NeoBundle     'vol2223/vim-colorblind-colorscheme'
        NeoBundle     't9md/vim-choosewin'
        NeoBundle     'itchyny/calendar.vim'
        NeoBundle     'osyo-manga/vim-anzu'
        NeoBundle     '844196/lightline-hybrid.vim'

    " util
        NeoBundle     'tomtom/tcomment_vim'
        NeoBundle     'tpope/vim-endwise'
        NeoBundleLazy 'haya14busa/incsearch.vim'
        NeoBundleLazy 'Shougo/unite.vim'
        NeoBundleLazy 'ujihisa/unite-colorscheme'
        NeoBundleLazy 'thinca/vim-scouter'
        NeoBundleLazy 'mattn/benchvimrc-vim'
        NeoBundle     'scrooloose/nerdtree'
        NeoBundle     'Xuyuanp/nerdtree-git-plugin'
        NeoBundle     'jistr/vim-nerdtree-tabs'
        NeoBundleLazy 'thinca/vim-quickrun'
        NeoBundle     'tpope/vim-fugitive'
        NeoBundle     'Shougo/vimshell.vim'
        NeoBundle     'editorconfig/editorconfig-vim'
        NeoBundle     'AndrewRadev/splitjoin.vim'
        NeoBundle     'AndrewRadev/linediff.vim'
        NeoBundle     'majutsushi/tagbar'
        NeoBundle     'Shougo/unite-outline'
        NeoBundle     'kmnk/vim-unite-giti'
        NeoBundle     'soramugi/auto-ctags.vim'
        NeoBundle     'Shougo/neomru.vim'
        NeoBundle     'osyo-manga/vim-watchdogs'
        NeoBundle     'osyo-manga/shabadou.vim'
        NeoBundle     'dannyob/quickfixstatus'
        NeoBundle     'KazuakiM/vim-qfsigns'

    " completation
        NeoBundle     'Shougo/neocomplete.vim'
        NeoBundle     'Shougo/neosnippet.vim'
        NeoBundle     'Shougo/neosnippet-snippets'

    " for git
        NeoBundle     'cohama/agit.vim'
        NeoBundle     'rhysd/committia.vim'
        " NeoBundle     'mhinz/vim-signify'
        NeoBundle     'airblade/vim-gitgutter'

    " for html
        NeoBundleLazy 'mattn/emmet-vim'
        NeoBundleLazy 'lilydjwg/colorizer'

    " for markdown
        NeoBundleLazy 'junegunn/goyo.vim'
        NeoBundleLazy 'kannokanno/previm'
        " NeoBundle     'rcmdnk/vim-markdown'
        " NeoBundle     'joker1007/vim-markdown-quote-syntax'

    " for ruby
        NeoBundleLazy 'noprompt/vim-yardoc'
        NeoBundleLazy 'sunaku/vim-ruby-minitest'
        NeoBundleLazy 'vim-ruby/vim-ruby'

    " for php
        NeoBundle     'vim-scripts/smarty-syntax'

    " for js
        NeoBundle     'jelera/vim-javascript-syntax'
        NeoBundle     'othree/javascript-libraries-syntax.vim'
        NeoBundle     'othree/yajs.vim'
endif



" Plugins config
" ------------------------------------------------------------------------------
if s:bundle_tap('neobundle.vim')
    nnoremap <silent><space>nl :<C-u>NeoBundleList<CR>
endif

if s:bundle_tap('vimproc')
    " TODO: disabledが動いてない
    call neobundle#config({
        \   'build': {
        \       'windows': 'tools\\update-dll-mingw',
        \       'cygwin' : 'make -f make_cygwin.mak',
        \       'mac'    : 'make',
        \       'linux'  : 'make',
        \       'unix'   : 'gmake'
        \   }
        \ })
endif

if s:bundle_tap('neocomplete.vim')
    call neobundle#config({
        \   'disabled': !has('lua')
        \ })

    " ロード時から補完スタート
    let g:neocomplete#enable_at_startup = 1

    " <F4>で補完切り替え
    nnoremap <F4> :<C-u>NeoCompleteToggle<CR>

    let g:neocomplete#enable_ignore_case = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_enable_camel_case_completion = 1
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns._ = '\h\w*'
    let g:neocomplete#max_list = 20
endif

if s:bundle_tap('indentLine')
    call neobundle#config({
        \   'lazy': 1,
        \   'on_cmd': 'IndentLinesToggle'
        \ })

    " <F5>でガイドの表示切り替え
    nnoremap <silent><F5> :<C-u>IndentLinesToggle<CR>

    " インデントの色を変更（ターミナル）
    let g:indentLine_color_term = 239

    " インデント表示文字列
    let g:indentLine_char = '¦'
endif

if s:bundle_tap('vim-quickrun')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {
        \     'mappings': '<Leader>r',
        \     'commands': 'QuickRun'
        \     }
        \ })

    let g:quickrun_config = {}
    let g:quickrun_config._ = {
        \   "outputter/buffer/split": ':lefta vertical',
        \   "outputter/buffer/close_on_empty": 0,
        \   "runner": "vimproc",
        \   "runner/vimproc/updatetime": 60
        \ }
    let g:quickrun_config.markdown ={
        \   "outputter": "null",
        \   "command"  : "open",
        \   "cmdopt"   : "-a",
        \   "args"     : 'Marked\ 2',
        \   "exec"     : "%c %o %a %s"
        \ }
    let g:quickrun_config['ruby.bundle'] = { 'command': 'ruby', 'cmdopt': 'bundle exec', 'exec': '%o %c %s' }
    autocmd my_filetype FileType ruby.bundle setlocal tabstop=2 shiftwidth=2
    let g:quickrun_config['php.rev'] = {
        \ 'command': './rev',
        \ 'cmdopt' : 'console --no-startup-text',
        \ 'exec'   : 'cat %s | grep -v "<?php" | grep -v "[\s\t]*//" | tr "\n" " " | %c %o'
        \ }
    let g:quickrun_config.json = {
        \ 'outputter/buffer/filetype': 'json',
        \ 'command': 'jq',
        \ 'cmdopt': '.',
        \ 'exec': 'cat %s | sed "s/[\\]\"/\"/g" |  %c %o',
        \ }
    let g:quickrun_config.slack = {
        \ 'outputter/buffer/close_on_empty': 1,
        \ 'command': 'slack',
        \ 'cmdopt': 'post --pre --username=めもっち --icon-emoji=:yunocchi:',
        \ 'exec': 'cat %s | %c %o',
        \ }

    " <C-c>でquickrun停止
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
endif

if s:bundle_tap('unite.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Unite'}
        \ })

    " スマートな大文字小文字区別
    let g:unite_enable_ignore_case = 1
    let g:unite_enable_smart_case = 1

    " バッファ一覧をUniteに置き換え
    nnoremap <Leader>b :<C-u>Unite buffer<CR>

    " タブ一覧をUniteに置き換え
    nnoremap <Leader>t :<C-u>Unite tab<CR>

    " /の代わり
    nnoremap ?? :<C-u>Unite line<CR>

    " <Leader><Leader>でUnite file
    function! DispatchUniteFileRecAsyncOrGit()
        if isdirectory(getcwd()."/.git")
            Unite file_rec/git:--cached
        else
            Unite file_rec/async
        endif
    endfunction
    nnoremap <Leader><Leader> :<C-u>call DispatchUniteFileRecAsyncOrGit()<CR>

    " <Leader>gでUnite grep
    function! DispatchUniteGrepOrGit()
        if isdirectory(getcwd()."/.git")
            Unite grep/git:. -no-empty -buffer-name=search-buffer
        else
            Unite grep:. -no-empty -buffer-name=search-buffer
        endif
    endfunction
    nnoremap <Leader>g :<C-u>call DispatchUniteGrepOrGit()<CR>

    " インサートモードオン
    let g:unite_enable_start_insert = 1

    " <Esc><Esc>でUniteを閉じる
    augroup unite_my_settings
        autocmd!
        autocmd FileType unite call s:unite_my_settings()
    augroup END
    function! s:unite_my_settings()
        nmap <silent><buffer><Esc><Esc> <Plug>(unite_exit)
        imap <silent><buffer><Esc><Esc> <Plug>(unite_exit)
        imap <silent><buffer><C-e> <End>
        imap <silent><buffer><C-k> <C-o>"_D
    endfunction

    " disable overwrite unite statusline
    if neobundle#is_installed('lightline.vim')
        let g:unite_force_overwrite_statusline=0
    endif

    " menu
    let g:unite_source_menu_menus = {}
    let g:unite_source_menu_menus.shortcut = {
        \ 'description': 'shortcut'
        \ }
    let g:unite_source_menu_menus.shortcut.command_candidates = [
        \ ['Reopen search-buffer', 'UniteResume search-buffer'],
        \ ['Create quickrun rev snippet buffer', 'tabnew | 0r ~/.vim/templates/rev.template | set ft=php.rev | QuickRun'],
        \ ['Delete all buffer', '%bd'],
        \ ['Show make task', 'Unite make/help'],
        \ ['Run test', '!phpunit %'],
        \ ['Run diff test', '!make diff_test'],
        \ ['Open test file', "execute 'vsplit ' . substitute(substitute(expand('%'), '^src/', 'tests/', ''), '\.php$', 'Test\.php', '')"],
        \ ['Toggle paste mode', 'set paste!'],
        \ ['Calendar', 'Calendar'],
        \ ['Clock', 'Calendar -view=clock'],
        \ ['Toggle line number', 'setlocal number!'],
        \ ['Edit vimrc', 'edit $MYVIMRC'],
        \ ['Edit vimrc_local', 'edit ~/.vim/vimrc_local'],
        \ ]
    command! UniteShortcut
        \ Unite
        \ menu:shortcut
    nnoremap S :<C-u>UniteShortcut<CR>

    inoremap <silent><C-x><C-x> <ESC>:<C-u>Unite file_rec/git:--cached::src/:tests/
        \ -default-action=continuous_insert -direction=botright -prompt-direction=top
        \ <CR>

    nnoremap <silent><F2> :<C-u>Unite memo/list
        \ -buffer-name=memo/list
        \ -winheight=15
        \ <CR>

    function! neobundle#hooks.on_source(bundle)
        " make/help
        let s:make_help_source = {
            \ 'name': 'make/help',
            \ 'syntax': 'uniteSource__Make_Help',
            \ 'hooks': {},
            \ }

        function! s:make_help_source.gather_candidates(args, context)
            let s:candidate_map = map(systemlist('make help'), '{
                \ "task": split(substitute(v:val, "\\e\\[[0-9;]\\+[mK]", "", "g"), "\\s\\{2,\\}")[0],
                \ "description": split(substitute(v:val, "\\e\\[[0-9;]\\+[mK]", "", "g"), "\\s\\{2,\\}")[1],
                \ }')
            let s:padding = max(map(copy(s:candidate_map), 'strlen(v:val.task)'))
            return map(copy(s:candidate_map), '{
                \ "word": printf("%-" . s:padding . "S  --  %s", v:val.task, v:val.description),
                \ "soruce": "make/help",
                \ "kind": "command",
                \ "action__command": (v:val.description =~ "[cC][lL][eE][aA][rR]" ? "!sudo make" : "!make") . " " . v:val.task,
                \ }')
        endfunction

        function! s:make_help_source.hooks.on_syntax(args, context)
            syntax match uniteSource__Make_Help_Task /[a-zA-Z_-]\+\ze\s*--/
                \ contained containedin=uniteSource__Make_Help
            highlight! default link uniteSource__Make_Help_Task ModeMsg
        endfunction

        call unite#define_source(s:make_help_source)

        " memo/list
        let s:memo_list_source = {
            \ 'name': 'memo/list',
            \ 'syntax': 'uniteSource__Memo_List',
            \ 'default_action': {'common': 'create'},
            \ 'action_table': {'create': {'description': 'create a new memo'}},
            \ 'hooks': {},
            \ }

        function! s:memo_list_source.gather_candidates(args, context)
            let s:files = map(split(glob(g:memo_path . '/' . '*.md'), '\n'), '{
                \ "date": fnamemodify(v:val, ":t:r")[0:9],
                \ "title": substitute(fnamemodify(v:val, ":t:r"), "^....-..-.._", "", ""),
                \ "path": v:val
                \ }')

            let s:padding = max(map(
                \ copy(s:files), 'strlen(substitute(substitute(v:val.title, "[ -~｡-ﾟ]", "s", "g"), "[^s]", "mm", "g"))'
                \ ))

            return map(copy(s:files), '{
                \ "word": printf("%-" . s:padding . "S  --  %s", v:val.title, v:val.date),
                \ "source": "memo/list",
                \ "kind": "file",
                \ "action__path": v:val.path,
                \ }')
        endfunction

        function! s:memo_list_source.change_candidates(args, context)
            let s:title = substitute(a:context.input, ' ', '-', 'g')
            let s:path = expand(printf('%s/%s_%s.md', g:memo_path, strftime('%Y-%m-%d'), s:title))
            if s:title != '' && !filereadable(s:path)
                return [{
                    \ "abbr": '[new memo] ' . s:title,
                    \ "word": s:title,
                    \ "action__title": s:title,
                    \ "action__path": s:path,
                    \ "source": "memo/list",
                    \ }]
            else
                return []
            endif
        endfunction

        function! s:memo_list_source.action_table.create.func(candidates)
            silent edit `=a:candidates.action__path`
            call append(0, ['# '.a:candidates.action__title])
        endfunction

        function! s:memo_list_source.hooks.on_syntax(args, context)
            syntax match uniteSource__Memo_List_Memo /--  ....-..-../ contained containedin=uniteSource__Memo_List
            highlight! default uniteSource__Memo_List_Memo ctermfg=7
        endfunction

        call unite#define_source(s:memo_list_source)
        call unite#custom_source('memo/list', 'sorters', 'sorter_reverse')

        " namespace
        let s:action = {
            \ 'description': 'insert word, continuous insert mode',
            \ }
        function! s:action.func(candidate) abort
            let s:namespace = substitute(
                \ a:candidate.word, '^src/\(.*\)\.php', '\=tr(submatch(1), "/", "\\")', 'g'
                \ )
            let s:old_register = {
                \ 'type': getregtype('"'),
                \ 'value': getreg('"'),
                \ }
            call setreg('"', s:namespace, 'v')
            if (col('$') > 1 && col('.') != (col('$') - 1))
                execute 'normal! ""gp'
                startinsert
            else
                execute 'normal! ""p'
                startinsert!
            endif
            call setreg('"', s:old_register.value, s:old_register.type)
        endfunction
        call unite#custom#action('source/file_rec/git/*', 'continuous_insert', s:action)
    endfunction
endif

if s:bundle_tap('incsearch.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'mappings': '<Plug>(incsearch-'}
        \ })

    " リマップ
    map / <Plug>(incsearch-forward)
    map ? <Plug>(incsearch-backward)
    map n <Plug>(incsearch-nohl-n)<Plug>(anzu-update-search-status)zz
    map N <Plug>(incsearch-nohl-N)<Plug>(anzu-update-search-status)zz

    let g:incsearch#magic = '\v'
endif

if s:bundle_tap('vim-over')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'OverCommandLine'}
        \ })

    " プロンプト
    let g:over_command_line_prompt = '[over]:'
    " 置換したらハイライトを消す
    let g:over_enable_auto_nohlsearch = 1

    " リマップ
    nnoremap <silent><Space>s/ :OverCommandLine s/<CR>
    vnoremap <silent><Space>s/ :OverCommandLine s/<CR>
    nnoremap <silent><Space>%s/ :OverCommandLine %s/<CR>
endif

if s:bundle_tap('previm')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'PrevimOpen'}
        \ })

    let g:previm_disable_default_css = 0
    let g:previm_custom_css_path = '~/dotfiles/etc/memo.css'
    let g:previm_show_header = 0
endif

if s:bundle_tap('nerdtree')
    nnoremap <C-n> :<C-u>NERDTreeToggle<CR>
    nnoremap <C-f> :<C-u>NERDTreeFind<CR>
    let g:NERDTreeMinimalUI = 1
    let g:NERDTreeMouseMode = 2
    let g:NERDTreeChDirMode = 1
    set mouse=a
    let g:NERDTreeMouseMode=3
    " 他のバッファをすべて閉じた時にNERDTreeが開いていたらNERDTreeも一緒に閉じる。
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
endif

if s:bundle_tap('vim-devicons')
    let g:WebDevIconsUnicodeGlyphDoubleWidth = 1
    let g:WebDevIconsUnicodeDecorateFolderNodes = 1
    let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
    let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
    let g:webdevicons_enable_unite = 1
    let g:webdevicons_enable_nerdtree = 1
endif

if s:bundle_tap('emmet-vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'filetypes': ['html', 'css', 'scss', 'less', 'php']}
        \ })

    let g:user_emmet_settings = {
        \ 'lang' : 'ja',
        \ 'html': {'indentation': '  '},
        \ 'php': {'indentation': '	'}
        \ }
endif

if s:bundle_tap('colorizer')
    call neobundle#config({
        \   'lazy': 1,
        \   'gui': 1,
        \   'autoload' : {'filetypes': ['html', 'css', 'scss', 'less']}
        \ })
endif

if s:bundle_tap('vim-scouter')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'commands': 'Scouter'}
        \ })
endif

if s:bundle_tap('goyo.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Goyo'}
        \ })
endif

if s:bundle_tap('vim-yardoc')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-ruby-minitest')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-ruby')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-markdown')
    let g:vim_markdown_frontmatter = 1
    let g:vim_markdown_folding_disabled = 1
endif

if s:bundle_tap('vim-markdown-quote-syntax')
endif

if s:bundle_tap('agit.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Agit'}
        \ })
endif

if s:bundle_tap('committia.vim')
endif

if s:bundle_tap('vimdoc-ja')
    set helplang=ja,en
endif

if s:bundle_tap('benchvimrc-vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'on_cmd': 'BenchVimrc'
        \ })
endif

if s:bundle_tap('vim-fugitive')
    call neobundle#config({
        \   'augroup': 'fugitive'
        \ })
endif

if s:bundle_tap('vimshell.vim')
    " Prompt
    let g:vimshell_prompt = '$ '
    let g:vimshell_user_prompt = '
        \ "\n".
        \ fnamemodify(getcwd(), ":~")
        \ '
    let g:vimshell_right_prompt = 'Get_branch()'

    function! Get_branch()
        let s:is_git_dir = s:chomp(system('git status >/dev/null 2>&1; echo $?'))
        if s:is_git_dir != '0' | return '' | endif

        let s:local_branch = s:chomp('['.system('git rev-parse --abbrev-ref HEAD').']')
        let s:remote_branch = s:chomp('['.system('git rev-parse --abbrev-ref "@{u}" 2>/dev/null').']')

        return s:local_branch.' →  '.s:remote_branch
    endfunction

    function! s:chomp(str)
        return substitute(a:str, '\n', '', 'g')
    endfunction

    " in VimShell
    augroup vimshell_my_keymap
        autocmd!
        autocmd FileType vimshell call s:vimshell_my_setting()
    augroup END
    function! s:vimshell_my_setting()
        setlocal nonumber
        imap <silent><buffer><C-l> <Plug>(vimshell_clear)
        imap <silent><buffer><C-r> <Plug>(vimshell_history_unite)
        imap <silent><buffer><C-e> <End>
        inoremap <silent><buffer><C-k> <C-o>D
    endfunction

    " call VimShell keybind
    nnoremap <silent><leader>a :<C-u>VimShellCreate -split<CR>
endif

if s:bundle_tap('vim-hybrid')
    set fillchars+=vert:\ 

    augroup my_color
        autocmd!
    augroup END

    if !has('gui_running')
        let g:hybrid_custom_term_colors = 1
    endif

    autocmd my_color VimEnter,Colorscheme * hi! link TabLine StatusLineNC
    autocmd my_color VimEnter,Colorscheme * hi! link TabLineFill StatusLineNC
    autocmd my_color VimEnter,Colorscheme * hi! link TabLineSel StatusLine
    autocmd my_color VimEnter,Colorscheme * hi! link VertSplit ColorColumn

    augroup modify_agit_diff_color
        autocmd!
    augroup END

    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitDiffAdd Special
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitStatAdded Special
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitDiffRemove Constant
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitStatRemoved Constant

    function! neobundle#hooks.on_source(bundle) abort
        set bg=dark
        colorscheme hybrid
    endfunction
endif

if s:bundle_tap('lightline.vim')
    let g:lightline = {}
    let g:lightline.colorscheme = 'hybrid'
    let g:lightline.component = {
        \ 'filename': '%f',
        \ 'lineinfo': '%l:%c',
        \ 'fullpath': '%F',
        \ 'branch': '%{fugitive#head()}',
        \ }
    let g:lightline.component_function = {
        \ 'anzu': 'anzu#search_status',
        \ }
    let g:lightline.active = {
        \ 'left': [['mode', 'paste'], ['branch'], ['readonly', 'filename', 'modified']],
        \ 'right': [['lineinfo', 'anzu'], ['filetype'], ['fileformat', 'fileencoding']]
        \ }
    let g:lightline.inactive = {
        \ 'left': [['fullpath']],
        \ 'right': [['branch']],
        \ }
    let g:lightline.tabline = {
        \ 'left': [['tabs']],
        \ 'right': [],
        \ }
endif

if s:bundle_tap('vim-fugitive') && neobundle#tap('nerdtree')
    augroup fix_fugitive
        autocmd!
        autocmd BufEnter * call fugitive#detect(expand('%:p'))
    augroup END
endif

if s:bundle_tap('vim-signify')
    nnoremap <silent><space>t :<C-u>SignifyToggle<CR>
    nnoremap <silent><space>h :<C-u>SignifyToggleHighlight<CR>
    nnoremap <silent><space>r :<C-u>SignifyRefresh<CR>
    nmap <silent><space>j <Plug>(signify-next-hunk)
    nmap <silent><space>k <Plug>(signify-prev-hunk)
endif

if s:bundle_tap('vim-gitgutter')
    nnoremap <silent><space>h :<C-u>GitGutterLineHighlightsToggle<CR>
    nnoremap <silent><space>j :<C-u>GitGutterNextHunk<CR>
    nnoremap <silent><space>k :<C-u>GitGutterPrevHunk<CR>
endif

if s:bundle_tap('neosnippet.vim')
    imap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    smap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    xmap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    let g:neosnippet#snippets_directory = '~/.vim/snippets/'
endif

if s:bundle_tap('unite-outline')
    nnoremap <silent> U :<C-u>Unite outline -vertical -direction=belowright<CR>
endif

if s:bundle_tap('tagbar')
    nnoremap <silent> T :<C-u>TagbarToggle<CR>
endif

if s:bundle_tap('vim-unite-giti')
    nnoremap <silent> <leader>s :<C-u>Unite giti/status<CR>
    nnoremap <silent> <leader>d :<C-u>Unite giti/log<CR>
endif

if s:bundle_tap('auto-ctags.vim')
    let g:auto_ctags = 0
    let g:auto_ctags_directory_list = ['.git']
endif

if s:bundle_tap('vim-choosewin')
    nmap `` <Plug>(choosewin)

    let g:choosewin_overlay_enable = 1
    let g:choosewin_overlay_clear_multibyte = 1
    let g:choosewin_statusline_replace = 0
    let g:choosewin_blink_on_land = 1
    let g:choosewin_return_on_single_win = 0
    let g:choosewin_color_overlay_current = {
        \ 'cterm': [9, 9],
        \ }
    let g:choosewin_color_overlay = {
        \ 'cterm': [7, 7],
        \ }
    let g:choosewin_color_label_current = {
        \ 'cterm': [7, 0]
        \ }
    let g:choosewin_color_label = {
        \ 'cterm': [0, 7]
        \ }
    let g:choosewin_color_other = {
        \ 'cterm': [0, 0]
        \ }
endif

if s:bundle_tap('vim-anzu')
    nmap * "zyiw:let @/ = @z<CR>:<C-u>set hlsearch<CR><Plug>(anzu-update-search-status)
    vmap * "zy:let @/ = @z<CR>:<C-u>set hlsearch<CR><Plug>(anzu-update-search-status)
    nmap <silent><Esc><Esc> <Plug>(anzu-clear-search-status):<C-u>nohlsearch<CR>
endif

if s:bundle_tap('vim-watchdogs')
    "書き込み後に構文チェックを行う
    let g:watchdogs_check_BufWritePost_enable = 1

    "一定時間キー入力がなかった場合に構文チェックを行う
    let g:watchdogs_check_CursorHold_enable = 1

    "falseのとき:wq時に実行しない
    let g:watchdogs_check_BufWritePost_enable_on_wq = 0

    "vim-hierでエラー箇所がハイライトされるので:WathcdogsRun後にquickfixウィンドウを自動的に閉じる
    let g:quickrun_config['watchdogs_checker/_'] = {
        \ 'outputter/quickfix/open_cmd': '',
        \ 'hook/qfsigns_update/enable_exit': 1,
        \ 'hook/qfsigns_update/priority_exit': 3,
        \ }

    " phpcs
    let s:phpcs_command = 'phpcs'
    if executable(s:phpcs_command)
        let s:error_format =
            \ '%-GFile\,Line\,Column\,Type\,Message\,Source\,Severity%.%#,'.
            \ '"%f"\,%l\,%c\,%t%*[a-zA-Z]\,"%m"\,%*[a-zA-Z0-9_.-]\,%*[0-9]%.%#'

        let g:quickrun_config["watchdogs_checker/phpcs"] = {
            \ "quickfix/errorformat": s:error_format,
            \ "command" : s:phpcs_command,
            \ "cmdopt" : "--report=csv --standard=ruleset.xml",
            \ "exec" : '%c %o %s:p',
            \ }

        let g:quickrun_config["php/watchdogs_checker"] = {
            \ "type" : "watchdogs_checker/phpcs",
            \ }
    endif

    function! neobundle#hooks.on_source(bundle) abort
        call watchdogs#setup(g:quickrun_config)
    endfunction
endif


" Finish
" ------------------------------------------------------------------------------
" load .vimrc_local if file readable
if filereadable(expand('~/.vim/vimrc_local'))
    source ~/.vim/vimrc_local
endif

" end neobundle block
call s:bundle_end()

" enable syntax
syntax on
