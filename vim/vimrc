" Init
" ------------------------------------------------------------------------------
set encoding=utf-8
scriptencoding utf-8

if !1 | finish | endif
if !&compatible | set nocompatible | endif

" viminfoã®å ´æ‰€
if isdirectory(expand('~/.vim'))
    set viminfo+=n~/.vim/viminfo
endif



" Basic
" ------------------------------------------------------------------------------
set noswapfile                        " ã‚¹ãƒ¯ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set nobackup                          " ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’ä½œæˆã—ãªã„
set noundofile                        " undoãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã—ãªã„
set backspace=indent,eol,start        " <BS>ãŒå‰Šé™¤ã™ã‚‹ä½ç½®ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã€è¡Œæœ«ã€æ”¹è¡Œãƒã‚¿ã‚®ï¼‰
set list                              " ç‰¹æ®Šæ–‡å­—ã‚’è¡¨ç¤º
set listchars=tab:>-,trail:-          " ç‰¹æ®Šæ–‡å­—ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿
set virtualedit=block                 " è‡ªç”±ãªçŸ©å½¢é¸æŠ
set expandtab                         " <Tab>ã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«å±•é–‹
set tabstop=4 shiftwidth=4            " <Tab>ã‚¹ãƒšãƒ¼ã‚¹å±•é–‹æ–‡å­—å¹…
set shiftround                        " ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’shiftwidthã«ä¸¸ã‚ã‚‹
set smarttab                          " è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
set autoindent                        " æ”¹è¡Œå¾Œã®è‡ªå‹•ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
if (v:version == 704 && has('patch338')) || v:version >= 705
    set breakindent                   " æŠ˜ã‚Šè¿”ã—ãŸè¡ŒãŒã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã«æ²¿ã†
endif
set synmaxcol=300                     " 1è¡Œã‚ãŸã‚Šã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹æœ‰åŠ¹æ–‡å­—æ•°
set number                            " è¡Œç•ªå·
set scrolloff=10                      " ãƒãƒƒãƒ•ã‚¡ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ™‚ã«ä¸Šä¸‹10è¡Œã‚’ç¢ºä¿
set showmatch                         " å¯¾å¿œã™ã‚‹ã‚«ãƒƒã‚³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
set matchtime=1                       " ã‚«ãƒƒã‚³é–“ç§»å‹•æ™‚é–“
set display=lastline                  " è¡ŒãŒé•·ãã¦ã‚‚è¡¨ç¤º
set splitright                        " åˆ†å‰²ãƒãƒƒãƒ•ã‚¡ã‚’å³ã«é–‹ã
set hidden                            " ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¿å­˜ã—ãªãã¦ã‚‚æ–°ã—ã„ãƒãƒƒãƒ•ã‚¡ã‚’é–‹ã
set laststatus=2                      " ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã‚’å¸¸ã«è¡¨ç¤º
set ruler                             " ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã«ç¾åœ¨è¡Œæƒ…å ±ã‚’è¡¨ç¤º
set showcmd                           " ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ä¸‹ã«å…¥åŠ›ä¸­ã‚³ãƒãƒ³ãƒ‰ã‚’è¡¨ç¤º
set noshowmode                        " ãƒ¢ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã—ãªã„
set cmdheight=2                       " ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ã®é«˜ã•
set wildmenu                          " ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³è£œå®Œ
set wildignorecase                    " ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³è£œå®Œã‚’å¤§æ–‡å­—ãƒ»å°æ–‡å­—ç„¡è¦–
set incsearch                         " ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ã‚¿ãƒ«ã‚µãƒ¼ãƒ
set hlsearch                          " ãƒãƒƒãƒæ–‡å­—åˆ—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
set nowrapscan                        " æœ€å¾Œã¾ã§æ¤œç´¢ã—ãŸã‚‰ã€æœ€åˆã®ãƒãƒƒãƒæ–‡å­—åˆ—ã«ç§»å‹•ã—ãªã„
set ignorecase                        " æ¤œç´¢æ–‡å­—åˆ—ã§å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set smartcase                         " æ¤œç´¢æ–‡å­—åˆ—ã§å¤§æ–‡å­—ãŒæ··åœ¨ã—ã¦ã„ã‚‹å ´åˆã¯åŒºåˆ¥ã™ã‚‹
set modeline                          " ãƒ¢ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æœ‰åŠ¹
set modelines=5                       " ãƒ¢ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’ä¸Šä¸‹5è¡Œã¾ã§æ¤œç´¢
set infercase                         " è£œå®Œæ™‚ã«å¤§æ–‡å­—ãƒ»å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„
set textwidth=0                       " è¡Œã‚ãŸã‚Šã®æœ€å¤§æ–‡å­—æ•°ï¼Ÿã‚’0ã«ï¼ˆformatoptionsï¼‰
set tags+=.git/tags                   " .gitã«ã‚ã‚‹ã‚¿ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚èª­ã‚€
set ttimeoutlen=10                    " ã‚­ãƒ¼ã‚·ãƒ¼ã‚±ãƒ³ã‚¹çµ‚äº†ã®å¾…ã¡æ™‚é–“ã‚’çŸ­ã



" Remap
" ------------------------------------------------------------------------------
nnoremap <Space> :
vnoremap <Space> :

" Yã®æŒ™å‹•ã‚’C, Dã¨æƒãˆã‚‹
nnoremap Y y$

" ä¸€æ–‡å­—å‰Šé™¤ã¯å‰Šé™¤ãƒ¬ã‚¸ã‚¹ã‚¿ã‚’ä½¿ç”¨
nnoremap x "_x
vnoremap x "_x

" ã‹ã£ã“
inoremap '' ''<C-G>U<Left>
inoremap "" ""<C-G>U<Left>
inoremap () ()<C-G>U<Left>
inoremap {} {}<C-G>U<Left>
inoremap [] []<C-G>U<Left>
inoremap <> <><C-G>U<Left>

" search
nnoremap <silent><Esc><Esc> :<C-u>nohlsearch<CR>
nnoremap n nzz
nnoremap N Nzz

" æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
inoremap <C-b> <C-G>U<Left>
inoremap <C-f> <C-G>U<Right>
inoremap <C-a> <C-G>U<Home>
inoremap <C-e> <C-G>U<End>
inoremap <C-k> <C-G>U<C-o>D

" visual mode
vnoremap v $h

" ã‚³ãƒãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-n> <Down>
cnoremap <C-p> <Up>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-k> <C-\>e getcmdpos() == 1 ? '' : getcmdline()[:getcmdpos()-2]<CR>

" ãƒãƒ¼ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰æ™‚ã«<CR>ã§æ”¹è¡Œ
nnoremap <CR> o<esc>

" ãƒãƒƒãƒ•ã‚¡æ“ä½œ
nnoremap <silent><Space>vs :<C-u>vsp<CR>
nnoremap <silent><Space>sp :<C-u>sp<CR>
nnoremap <silent><Space>vn :<C-u>vnew<CR>
nnoremap <silent><Space>st :<C-u>tabnew<CR>
nnoremap <silent><Left> <C-w><
nnoremap <silent><Right> <C-w>>
nnoremap <silent><Tab> <C-w>w

" toggle relative line number and column highlight
nnoremap <silent><F3> :<C-u>setlocal relativenumber!<CR>
nnoremap <silent><F1> :<C-u><C-\>e'setlocal colorcolumn='.(&colorcolumn ? '' : '120')<CR><CR>
nnoremap <silent><leader>c :<C-u>setlocal cursorcolumn!<CR>

" help
nnoremap <C-h> :h<Space>

" echo file path
nnoremap <C-g> 1<C-g>

" <C-w>oã‚’ä¸Šæ›¸ã
command! Big wincmd _ | wincmd |
nnoremap <silent><C-w>o :<C-u>Big<CR>

" 0ã¨^ã‚’å…¥ã‚Œæ›¿ãˆ
nnoremap 0 ^
nnoremap ^ 0

" *ã—ã¦ã‚‚æ¬¡ã®å€™è£œã¸ç§»å‹•ã—ãªã„ã‚ˆã†ã«
nnoremap * "zyiw:let @/ = @z<CR>:<C-u>set hlsearch<CR>

" ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ¢ãƒ¼ãƒ‰ã§é¸æŠä¸­ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¤œç´¢
vnoremap * "zy:let @/ = @z<CR>:<C-u>set hlsearch<CR>

" cã—ãŸã¨ãã®å…ƒãƒ†ã‚­ã‚¹ãƒˆæ ¼ç´å…ˆãƒ¬ã‚¸ã‚¹ã‚¿ã‚’å‰Šé™¤ãƒ¬ã‚¸ã‚¹ã‚¿ã¸å¤‰æ›´
vnoremap c "_c

" ç¸¦åˆ†å‰²ã§ã‚¿ã‚°ã‚¸ãƒ£ãƒ³ãƒ—
nnoremap <C-]> :vsp<CR> :exe("tjump ".expand('<cword>'))<CR>

" è¡Œã‚’ç§»å‹•
map K <nop>
vnoremap K "zx<UP>"zP`[V`]
vnoremap J "zx"zp`[V`]



" File type
" ------------------------------------------------------------------------------
augroup my_filetype
    autocmd!
    autocmd FileType help nnoremap <silent><buffer>q :quit<CR>
    autocmd FileType help wincmd L
    autocmd FileType html,css,less,scss,ruby,yaml,javascript setlocal tabstop=2 shiftwidth=2
    autocmd FileType php setlocal noexpandtab tabstop=4 shiftwidth=4
    autocmd FileType html inoremap <buffer></ </<C-x><C-o>
    autocmd FileType markdown hi! def link markdownItalic Normal
    autocmd BufNewFile,BufRead *.{md,mdwn,mkd,mkdn} setlocal filetype=markdown
augroup END



" Statusline
" ------------------------------------------------------------------------------
set statusline =\ %F\ \|\ %{&modified?'+\ \|':&modifiable?'':'-\ \|'}
set statusline+=%=\|\ %{(&fenc!=''?&fenc:&enc).':'.&ff}\ \|\ %{&filetype!=''?&filetype:'no\ ft'}\ \|\ %l:%c\ 



" Other
" ------------------------------------------------------------------------------
" Use vsplit mode (?)
" http://qiita.com/kefir_/items/c725731d33de4d8fb096
if has("vim_starting") && !has('gui_running') && has('vertsplit')
    function! g:EnableVsplitMode()
        " enable origin mode and left/right margins
        let &t_CS = "y"
        let &t_ti = &t_ti . "\e[?6;69h"
        let &t_te = "\e[?6;69l\e[999H" . &t_te
        let &t_CV = "\e[%i%p1%d;%p2%ds"
        call writefile([ "\e[?6;69h" ], "/dev/tty", "a")
    endfunction

    " old vim does not ignore CPR
    map <special> <Esc>[3;9R <Nop>

    " new vim can't handle CPR with direct mapping
    " map <expr> ^[[3;3R g:EnableVsplitMode()
    set t_F9=[3;3R
    map <expr> <t_F9> g:EnableVsplitMode()
    let &t_RV .= "\e[?6;69h\e[1;3s\e[3;9H\e[6n\e[0;0s\e[?6;69l"
endif

" ç®¡ç†è€…æ¨©é™ã§æ›¸ãè¾¼ã¿
if executable('sudo') && executable('tee')
    cnoremap w!! %!sudo tee > /dev/null %
endif

" Vimã‚¹ã‚¯ãƒªãƒ—ãƒˆã®è¡Œç¶™ç¶šã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆå¹…
let g:vim_indent_cont = 4

" æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã®ã‚¯ã‚½ã¿ãŸã„ãªæŒ™å‹•ã‚’åˆ‡ã‚‹
augroup no_comment
    autocmd!
    autocmd BufEnter * setlocal fo-=r
    autocmd BufEnter * setlocal fo-=o
    autocmd BufEnter * setlocal fo-=c
    autocmd BufEnter * setlocal fo-=t
    autocmd BufEnter * setlocal fo-=q
augroup END

" å…¨ã¦ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¡¨ç¤º
command! -nargs=* -complete=mapping AllMaps map <args> | map! <args> | lamp <args>

" ç¾åœ¨è¡Œãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚«ãƒ¬ãƒ³ãƒˆãƒãƒƒãƒ•ã‚¡ã®ã¿ã«é©ç”¨
augroup highlight_cursorline_on_current_buffer
    autocmd!
    autocmd BufLeave,WinLeave * setlocal nocursorline
    autocmd BufEnter,WinEnter * setlocal cursorline
augroup END

" ã‚«ãƒ¼ã‚½ãƒ«è¡Œãƒã‚¤ãƒ©ã‚¤ãƒˆæ™‚ã®ç‰¹æ®Šæ–‡å­—ã®è‰²
augroup special_key_highlight
    autocmd!
    autocmd VimEnter,WinEnter * match NonText '^\s\+'
augroup END

" å¤–éƒ¨ã§ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆï¼ˆã‹ã¤ã€ç·¨é›†ã—ã¦ã„ãªã„å ´åˆï¼‰ã¯è‡ªå‹•ã§ãƒªãƒ­ãƒ¼ãƒ‰ã™ã‚‹
set autoread
augroup checktime
    autocmd!
    autocmd WinEnter * checktime
augroup END

" æŒ¿å…¥ãƒ¢ãƒ¼ãƒ‰ã‚’æŠœã‘ãŸéš›ã€å¼·åˆ¶çš„ã«ãƒšãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã‚’è§£é™¤ã™ã‚‹
augroup leave_paste_mode_auto
    autocmd!
    autocmd InsertLeave * set nopaste
augroup END



" NeoBundle wrap functions
" ------------------------------------------------------------------------------
function! s:bundle_tap(bundle)
    return exists('*neobundle#tap') && neobundle#tap(a:bundle)
endfunction

function! s:bundle_end()
    try
        call neobundle#untap()
        call neobundle#end()
        filetype plugin indent on
        NeoBundleCheck
        if !has('vim_starting')
            call neobundle#call_hook('on_source')
        endif
    catch
    endtry
endfunction



" Load plugins list
" ------------------------------------------------------------------------------
if isdirectory(expand('~/.vim/bundle/neobundle.vim'))
    if has('vim_starting')
        set rtp+=~/.vim/bundle/neobundle.vim/
    endif
    call neobundle#begin(expand('~/.vim/bundle/'))

    NeoBundleFetch 'Shougo/neobundle.vim'

    " base
        NeoBundle     'Shougo/vimproc.vim'
        NeoBundle     'vim-jp/vimdoc-ja'

    " looks
        if !filereadable(expand('~/.vim/disable_devicon'))
            NeoBundle 'ryanoasis/vim-devicons'
        endif
        NeoBundle     'altercation/vim-colors-solarized'
        NeoBundle     'atelierbram/vim-colors_duotones'
        NeoBundle     'cocopon/iceberg.vim'
        NeoBundle     'morhetz/gruvbox'
        NeoBundle     'tomasr/molokai'
        NeoBundle     'NLKNguyen/papercolor-theme'
        NeoBundle     'w0ng/vim-hybrid'
        NeoBundle     'itchyny/lightline.vim'
        NeoBundle     'vol2223/vim-colorblind-colorscheme'
        NeoBundle     't9md/vim-choosewin'
        NeoBundle     'itchyny/calendar.vim'
        NeoBundle     'osyo-manga/vim-anzu'
        NeoBundle     '844196/lightline-hybrid.vim'

    " util
        NeoBundle     'tomtom/tcomment_vim'
        NeoBundle     'tpope/vim-endwise'
        NeoBundleLazy 'haya14busa/incsearch.vim'
        NeoBundleLazy 'Shougo/unite.vim'
        NeoBundleLazy 'ujihisa/unite-colorscheme'
        NeoBundleLazy 'thinca/vim-scouter'
        NeoBundleLazy 'mattn/benchvimrc-vim'
        NeoBundle     'scrooloose/nerdtree'
        NeoBundle     'Xuyuanp/nerdtree-git-plugin'
        NeoBundle     'jistr/vim-nerdtree-tabs'
        NeoBundleLazy 'thinca/vim-quickrun'
        NeoBundle     'tpope/vim-fugitive'
        NeoBundle     'Shougo/vimshell.vim'
        NeoBundle     'editorconfig/editorconfig-vim'
        NeoBundle     'AndrewRadev/splitjoin.vim'
        NeoBundle     'AndrewRadev/linediff.vim'
        NeoBundle     'majutsushi/tagbar'
        NeoBundle     'Shougo/unite-outline'
        NeoBundle     'kmnk/vim-unite-giti'
        NeoBundle     'soramugi/auto-ctags.vim'
        NeoBundle     'Shougo/neomru.vim'
        NeoBundle     'osyo-manga/vim-watchdogs'
        NeoBundle     'osyo-manga/shabadou.vim'
        NeoBundle     'dannyob/quickfixstatus'
        NeoBundle     'KazuakiM/vim-qfsigns'

    " completation
        NeoBundle     'Shougo/neocomplete.vim'
        NeoBundle     'Shougo/neosnippet.vim'
        NeoBundle     'Shougo/neosnippet-snippets'

    " for git
        NeoBundle     'cohama/agit.vim'
        NeoBundle     'rhysd/committia.vim'
        " NeoBundle     'mhinz/vim-signify'
        NeoBundle     'airblade/vim-gitgutter'

    " for html
        NeoBundleLazy 'mattn/emmet-vim'
        NeoBundleLazy 'lilydjwg/colorizer'

    " for markdown
        NeoBundleLazy 'junegunn/goyo.vim'
        NeoBundleLazy 'kannokanno/previm'
        " NeoBundle     'rcmdnk/vim-markdown'
        " NeoBundle     'joker1007/vim-markdown-quote-syntax'

    " for ruby
        NeoBundleLazy 'noprompt/vim-yardoc'
        NeoBundleLazy 'sunaku/vim-ruby-minitest'
        NeoBundleLazy 'vim-ruby/vim-ruby'

    " for php
        NeoBundle     'vim-scripts/smarty-syntax'

    " for js
        NeoBundle     'jelera/vim-javascript-syntax'
        NeoBundle     'othree/javascript-libraries-syntax.vim'
        NeoBundle     'othree/yajs.vim'
endif



" Plugins config
" ------------------------------------------------------------------------------
if s:bundle_tap('neobundle.vim')
    nnoremap <silent><space>nl :<C-u>NeoBundleList<CR>
endif

if s:bundle_tap('vimproc')
    " TODO: disabledãŒå‹•ã„ã¦ãªã„
    call neobundle#config({
        \   'build': {
        \       'windows': 'tools\\update-dll-mingw',
        \       'cygwin' : 'make -f make_cygwin.mak',
        \       'mac'    : 'make',
        \       'linux'  : 'make',
        \       'unix'   : 'gmake'
        \   }
        \ })
endif

if s:bundle_tap('neocomplete.vim')
    call neobundle#config({
        \   'disabled': !has('lua')
        \ })

    " ãƒ­ãƒ¼ãƒ‰æ™‚ã‹ã‚‰è£œå®Œã‚¹ã‚¿ãƒ¼ãƒˆ
    let g:neocomplete#enable_at_startup = 1

    " <F4>ã§è£œå®Œåˆ‡ã‚Šæ›¿ãˆ
    nnoremap <F4> :<C-u>NeoCompleteToggle<CR>

    let g:neocomplete#enable_ignore_case = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_enable_camel_case_completion = 1
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns._ = '\h\w*'
    let g:neocomplete#max_list = 20
endif

if s:bundle_tap('indentLine')
    call neobundle#config({
        \   'lazy': 1,
        \   'on_cmd': 'IndentLinesToggle'
        \ })

    " <F5>ã§ã‚¬ã‚¤ãƒ‰ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    nnoremap <silent><F5> :<C-u>IndentLinesToggle<CR>

    " ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã®è‰²ã‚’å¤‰æ›´ï¼ˆã‚¿ãƒ¼ãƒŸãƒŠãƒ«ï¼‰
    let g:indentLine_color_term = 239

    " ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆè¡¨ç¤ºæ–‡å­—åˆ—
    let g:indentLine_char = 'Â¦'
endif

if s:bundle_tap('vim-quickrun')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {
        \     'mappings': '<Leader>r',
        \     'commands': 'QuickRun'
        \     }
        \ })

    let g:quickrun_config = {}
    let g:quickrun_config._ = {
        \   "outputter/buffer/split": ':lefta vertical',
        \   "outputter/buffer/close_on_empty": 0,
        \   "runner": "vimproc",
        \   "runner/vimproc/updatetime": 60
        \ }
    let g:quickrun_config.markdown ={
        \   "outputter": "null",
        \   "command"  : "open",
        \   "cmdopt"   : "-a",
        \   "args"     : 'Marked\ 2',
        \   "exec"     : "%c %o %a %s"
        \ }
    let g:quickrun_config['ruby.bundle'] = { 'command': 'ruby', 'cmdopt': 'bundle exec', 'exec': '%o %c %s' }
    autocmd my_filetype FileType ruby.bundle setlocal tabstop=2 shiftwidth=2
    let g:quickrun_config['php.rev'] = {
        \ 'command': './rev',
        \ 'cmdopt' : 'console --no-startup-text',
        \ 'exec'   : 'cat %s | grep -v "<?php" | grep -v "[\s\t]*//" | tr "\n" " " | %c %o'
        \ }
    let g:quickrun_config.json = {
        \ 'outputter/buffer/filetype': 'json',
        \ 'command': 'jq',
        \ 'cmdopt': '.',
        \ 'exec': 'cat %s | sed "s/[\\]\"/\"/g" |  %c %o',
        \ }
    let g:quickrun_config.slack = {
        \ 'outputter/buffer/close_on_empty': 1,
        \ 'command': 'slack',
        \ 'cmdopt': 'post --pre --username=ã‚ã‚‚ã£ã¡ --icon-emoji=:yunocchi:',
        \ 'exec': 'cat %s | %c %o',
        \ }

    " <C-c>ã§quickrunåœæ­¢
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
endif

if s:bundle_tap('unite.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Unite'}
        \ })

    " ã‚¹ãƒãƒ¼ãƒˆãªå¤§æ–‡å­—å°æ–‡å­—åŒºåˆ¥
    let g:unite_enable_ignore_case = 1
    let g:unite_enable_smart_case = 1

    " ãƒãƒƒãƒ•ã‚¡ä¸€è¦§ã‚’Uniteã«ç½®ãæ›ãˆ
    nnoremap <Leader>b :<C-u>Unite buffer<CR>

    " ã‚¿ãƒ–ä¸€è¦§ã‚’Uniteã«ç½®ãæ›ãˆ
    nnoremap <Leader>t :<C-u>Unite tab<CR>

    " /ã®ä»£ã‚ã‚Š
    nnoremap ?? :<C-u>Unite line<CR>

    " <Leader><Leader>ã§Unite file
    function! DispatchUniteFileRecAsyncOrGit()
        if isdirectory(getcwd()."/.git")
            Unite file_rec/git:--cached
        else
            Unite file_rec/async
        endif
    endfunction
    nnoremap <Leader><Leader> :<C-u>call DispatchUniteFileRecAsyncOrGit()<CR>

    " <Leader>gã§Unite grep
    function! DispatchUniteGrepOrGit()
        if isdirectory(getcwd()."/.git")
            Unite grep/git:. -no-empty -buffer-name=search-buffer
        else
            Unite grep:. -no-empty -buffer-name=search-buffer
        endif
    endfunction
    nnoremap <Leader>g :<C-u>call DispatchUniteGrepOrGit()<CR>

    " ã‚¤ãƒ³ã‚µãƒ¼ãƒˆãƒ¢ãƒ¼ãƒ‰ã‚ªãƒ³
    let g:unite_enable_start_insert = 1

    " <Esc><Esc>ã§Uniteã‚’é–‰ã˜ã‚‹
    augroup unite_my_settings
        autocmd!
        autocmd FileType unite call s:unite_my_settings()
    augroup END
    function! s:unite_my_settings()
        nmap <silent><buffer><Esc><Esc> <Plug>(unite_exit)
        imap <silent><buffer><Esc><Esc> <Plug>(unite_exit)
        imap <silent><buffer><C-e> <End>
        imap <silent><buffer><C-k> <C-o>"_D
    endfunction

    " disable overwrite unite statusline
    if neobundle#is_installed('lightline.vim')
        let g:unite_force_overwrite_statusline=0
    endif

    " menu
    let g:unite_source_menu_menus = {}
    let g:unite_source_menu_menus.shortcut = {
        \ 'description': 'shortcut'
        \ }
    let g:unite_source_menu_menus.shortcut.command_candidates = [
        \ ['Reopen search-buffer', 'UniteResume search-buffer'],
        \ ['Create quickrun rev snippet buffer', 'tabnew | 0r ~/.vim/templates/rev.template | set ft=php.rev | QuickRun'],
        \ ['Delete all buffer', '%bd'],
        \ ['Show make task', 'Unite make/help'],
        \ ['Run test', '!phpunit %'],
        \ ['Run diff test', '!make diff_test'],
        \ ['Open test file', "execute 'vsplit ' . substitute(substitute(expand('%'), '^src/', 'tests/', ''), '\.php$', 'Test\.php', '')"],
        \ ['Toggle paste mode', 'set paste!'],
        \ ['Calendar', 'Calendar'],
        \ ['Clock', 'Calendar -view=clock'],
        \ ['Toggle line number', 'setlocal number!'],
        \ ['Edit vimrc', 'edit $MYVIMRC'],
        \ ['Edit vimrc_local', 'edit ~/.vim/vimrc_local'],
        \ ]
    command! UniteShortcut
        \ Unite
        \ menu:shortcut
    nnoremap S :<C-u>UniteShortcut<CR>

    inoremap <silent><C-x><C-x> <ESC>:<C-u>Unite file_rec/git:--cached::src/:tests/
        \ -default-action=continuous_insert -direction=botright -prompt-direction=top
        \ <CR>

    nnoremap <silent><F2> :<C-u>Unite memo/list
        \ -buffer-name=memo/list
        \ -winheight=15
        \ <CR>

    function! neobundle#hooks.on_source(bundle)
        " make/help
        let s:make_help_source = {
            \ 'name': 'make/help',
            \ 'syntax': 'uniteSource__Make_Help',
            \ 'hooks': {},
            \ }

        function! s:make_help_source.gather_candidates(args, context)
            let s:candidate_map = map(systemlist('make help'), '{
                \ "task": split(substitute(v:val, "\\e\\[[0-9;]\\+[mK]", "", "g"), "\\s\\{2,\\}")[0],
                \ "description": split(substitute(v:val, "\\e\\[[0-9;]\\+[mK]", "", "g"), "\\s\\{2,\\}")[1],
                \ }')
            let s:padding = max(map(copy(s:candidate_map), 'strlen(v:val.task)'))
            return map(copy(s:candidate_map), '{
                \ "word": printf("%-" . s:padding . "S  --  %s", v:val.task, v:val.description),
                \ "soruce": "make/help",
                \ "kind": "command",
                \ "action__command": (v:val.description =~ "[cC][lL][eE][aA][rR]" ? "!sudo make" : "!make") . " " . v:val.task,
                \ }')
        endfunction

        function! s:make_help_source.hooks.on_syntax(args, context)
            syntax match uniteSource__Make_Help_Task /[a-zA-Z_-]\+\ze\s*--/
                \ contained containedin=uniteSource__Make_Help
            highlight! default link uniteSource__Make_Help_Task ModeMsg
        endfunction

        call unite#define_source(s:make_help_source)

        " memo/list
        let s:memo_list_source = {
            \ 'name': 'memo/list',
            \ 'syntax': 'uniteSource__Memo_List',
            \ 'default_action': {'common': 'create'},
            \ 'action_table': {'create': {'description': 'create a new memo'}},
            \ 'hooks': {},
            \ }

        function! s:memo_list_source.gather_candidates(args, context)
            let s:files = map(split(glob(g:memo_path . '/' . '*.md'), '\n'), '{
                \ "date": fnamemodify(v:val, ":t:r")[0:9],
                \ "title": substitute(fnamemodify(v:val, ":t:r"), "^....-..-.._", "", ""),
                \ "path": v:val
                \ }')

            let s:padding = max(map(
                \ copy(s:files), 'strlen(substitute(substitute(v:val.title, "[ -~ï½¡-ï¾Ÿ]", "s", "g"), "[^s]", "mm", "g"))'
                \ ))

            return map(copy(s:files), '{
                \ "word": printf("%-" . s:padding . "S  --  %s", v:val.title, v:val.date),
                \ "source": "memo/list",
                \ "kind": "file",
                \ "action__path": v:val.path,
                \ }')
        endfunction

        function! s:memo_list_source.change_candidates(args, context)
            let s:title = substitute(a:context.input, ' ', '-', 'g')
            let s:path = expand(printf('%s/%s_%s.md', g:memo_path, strftime('%Y-%m-%d'), s:title))
            if s:title != '' && !filereadable(s:path)
                return [{
                    \ "abbr": '[new memo] ' . s:title,
                    \ "word": s:title,
                    \ "action__title": s:title,
                    \ "action__path": s:path,
                    \ "source": "memo/list",
                    \ }]
            else
                return []
            endif
        endfunction

        function! s:memo_list_source.action_table.create.func(candidates)
            silent edit `=a:candidates.action__path`
            call append(0, ['# '.a:candidates.action__title])
        endfunction

        function! s:memo_list_source.hooks.on_syntax(args, context)
            syntax match uniteSource__Memo_List_Memo /--  ....-..-../ contained containedin=uniteSource__Memo_List
            highlight! default uniteSource__Memo_List_Memo ctermfg=7
        endfunction

        call unite#define_source(s:memo_list_source)
        call unite#custom_source('memo/list', 'sorters', 'sorter_reverse')

        " namespace
        let s:action = {
            \ 'description': 'insert word, continuous insert mode',
            \ }
        function! s:action.func(candidate) abort
            let s:namespace = substitute(
                \ a:candidate.word, '^src/\(.*\)\.php', '\=tr(submatch(1), "/", "\\")', 'g'
                \ )
            let s:old_register = {
                \ 'type': getregtype('"'),
                \ 'value': getreg('"'),
                \ }
            call setreg('"', s:namespace, 'v')
            if (col('$') > 1 && col('.') != (col('$') - 1))
                execute 'normal! ""gp'
                startinsert
            else
                execute 'normal! ""p'
                startinsert!
            endif
            call setreg('"', s:old_register.value, s:old_register.type)
        endfunction
        call unite#custom#action('source/file_rec/git/*', 'continuous_insert', s:action)
    endfunction
endif

if s:bundle_tap('incsearch.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'mappings': '<Plug>(incsearch-'}
        \ })

    " ãƒªãƒãƒƒãƒ—
    map / <Plug>(incsearch-forward)
    map ? <Plug>(incsearch-backward)
    map n <Plug>(incsearch-nohl-n)<Plug>(anzu-update-search-status)zz
    map N <Plug>(incsearch-nohl-N)<Plug>(anzu-update-search-status)zz

    let g:incsearch#magic = '\v'
endif

if s:bundle_tap('vim-over')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'OverCommandLine'}
        \ })

    " ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    let g:over_command_line_prompt = '[over]:'
    " ç½®æ›ã—ãŸã‚‰ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’æ¶ˆã™
    let g:over_enable_auto_nohlsearch = 1

    " ãƒªãƒãƒƒãƒ—
    nnoremap <silent><Space>s/ :OverCommandLine s/<CR>
    vnoremap <silent><Space>s/ :OverCommandLine s/<CR>
    nnoremap <silent><Space>%s/ :OverCommandLine %s/<CR>
endif

if s:bundle_tap('previm')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'PrevimOpen'}
        \ })

    let g:previm_disable_default_css = 0
    let g:previm_custom_css_path = '~/dotfiles/etc/memo.css'
    let g:previm_show_header = 0
endif

if s:bundle_tap('nerdtree')
    nnoremap <C-n> :<C-u>NERDTreeToggle<CR>
    nnoremap <C-f> :<C-u>NERDTreeFind<CR>
    let g:NERDTreeMinimalUI = 1
    let g:NERDTreeMouseMode = 2
    let g:NERDTreeChDirMode = 1
    set mouse=a
    let g:NERDTreeMouseMode=3
    " ä»–ã®ãƒãƒƒãƒ•ã‚¡ã‚’ã™ã¹ã¦é–‰ã˜ãŸæ™‚ã«NERDTreeãŒé–‹ã„ã¦ã„ãŸã‚‰NERDTreeã‚‚ä¸€ç·’ã«é–‰ã˜ã‚‹ã€‚
    autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
endif

if s:bundle_tap('vim-devicons')
    let g:WebDevIconsUnicodeGlyphDoubleWidth = 1
    let g:WebDevIconsUnicodeDecorateFolderNodes = 1
    let g:WebDevIconsNerdTreeAfterGlyphPadding = ' '
    let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
    let g:webdevicons_enable_unite = 1
    let g:webdevicons_enable_nerdtree = 1
endif

if s:bundle_tap('emmet-vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'filetypes': ['html', 'css', 'scss', 'less', 'php']}
        \ })

    let g:user_emmet_settings = {
        \ 'lang' : 'ja',
        \ 'html': {'indentation': '  '},
        \ 'php': {'indentation': '	'}
        \ }
endif

if s:bundle_tap('colorizer')
    call neobundle#config({
        \   'lazy': 1,
        \   'gui': 1,
        \   'autoload' : {'filetypes': ['html', 'css', 'scss', 'less']}
        \ })
endif

if s:bundle_tap('vim-scouter')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload' : {'commands': 'Scouter'}
        \ })
endif

if s:bundle_tap('goyo.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Goyo'}
        \ })
endif

if s:bundle_tap('vim-yardoc')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-ruby-minitest')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-ruby')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'filetypes': 'ruby'}
        \ })
endif

if s:bundle_tap('vim-markdown')
    let g:vim_markdown_frontmatter = 1
    let g:vim_markdown_folding_disabled = 1
endif

if s:bundle_tap('vim-markdown-quote-syntax')
endif

if s:bundle_tap('agit.vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'autoload': {'commands': 'Agit'}
        \ })
endif

if s:bundle_tap('committia.vim')
endif

if s:bundle_tap('vimdoc-ja')
    set helplang=ja,en
endif

if s:bundle_tap('benchvimrc-vim')
    call neobundle#config({
        \   'lazy': 1,
        \   'on_cmd': 'BenchVimrc'
        \ })
endif

if s:bundle_tap('vim-fugitive')
    call neobundle#config({
        \   'augroup': 'fugitive'
        \ })
endif

if s:bundle_tap('vimshell.vim')
    " Prompt
    let g:vimshell_prompt = '$ '
    let g:vimshell_user_prompt = '
        \ "\n".
        \ fnamemodify(getcwd(), ":~")
        \ '
    let g:vimshell_right_prompt = 'Get_branch()'

    function! Get_branch()
        let s:is_git_dir = s:chomp(system('git status >/dev/null 2>&1; echo $?'))
        if s:is_git_dir != '0' | return '' | endif

        let s:local_branch = s:chomp('['.system('git rev-parse --abbrev-ref HEAD').']')
        let s:remote_branch = s:chomp('['.system('git rev-parse --abbrev-ref "@{u}" 2>/dev/null').']')

        return s:local_branch.' â†’  '.s:remote_branch
    endfunction

    function! s:chomp(str)
        return substitute(a:str, '\n', '', 'g')
    endfunction

    " in VimShell
    augroup vimshell_my_keymap
        autocmd!
        autocmd FileType vimshell call s:vimshell_my_setting()
    augroup END
    function! s:vimshell_my_setting()
        setlocal nonumber
        imap <silent><buffer><C-l> <Plug>(vimshell_clear)
        imap <silent><buffer><C-r> <Plug>(vimshell_history_unite)
        imap <silent><buffer><C-e> <End>
        inoremap <silent><buffer><C-k> <C-o>D
    endfunction

    " call VimShell keybind
    nnoremap <silent><leader>a :<C-u>VimShellCreate -split<CR>
endif

if s:bundle_tap('vim-hybrid')
    set fillchars+=vert:\ 

    augroup my_color
        autocmd!
    augroup END

    if !has('gui_running')
        let g:hybrid_custom_term_colors = 1
    endif

    autocmd my_color VimEnter,Colorscheme * hi! link TabLine StatusLineNC
    autocmd my_color VimEnter,Colorscheme * hi! link TabLineFill StatusLineNC
    autocmd my_color VimEnter,Colorscheme * hi! link TabLineSel StatusLine
    autocmd my_color VimEnter,Colorscheme * hi! link VertSplit ColorColumn

    augroup modify_agit_diff_color
        autocmd!
    augroup END

    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitDiffAdd Special
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitStatAdded Special
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitDiffRemove Constant
    autocmd modify_agit_diff_color Filetype agit_diff hi! link agitStatRemoved Constant

    function! neobundle#hooks.on_source(bundle) abort
        set bg=dark
        colorscheme hybrid
    endfunction
endif

if s:bundle_tap('lightline.vim')
    let g:lightline = {}
    let g:lightline.colorscheme = 'hybrid'
    let g:lightline.component = {
        \ 'filename': '%f',
        \ 'lineinfo': '%l:%c',
        \ 'fullpath': '%F',
        \ 'branch': '%{fugitive#head()}',
        \ }
    let g:lightline.component_function = {
        \ 'anzu': 'anzu#search_status',
        \ }
    let g:lightline.active = {
        \ 'left': [['mode', 'paste'], ['branch'], ['readonly', 'filename', 'modified']],
        \ 'right': [['lineinfo', 'anzu'], ['filetype'], ['fileformat', 'fileencoding']]
        \ }
    let g:lightline.inactive = {
        \ 'left': [['fullpath']],
        \ 'right': [['branch']],
        \ }
    let g:lightline.tabline = {
        \ 'left': [['tabs']],
        \ 'right': [],
        \ }
endif

if s:bundle_tap('vim-fugitive') && neobundle#tap('nerdtree')
    augroup fix_fugitive
        autocmd!
        autocmd BufEnter * call fugitive#detect(expand('%:p'))
    augroup END
endif

if s:bundle_tap('vim-signify')
    nnoremap <silent><space>t :<C-u>SignifyToggle<CR>
    nnoremap <silent><space>h :<C-u>SignifyToggleHighlight<CR>
    nnoremap <silent><space>r :<C-u>SignifyRefresh<CR>
    nmap <silent><space>j <Plug>(signify-next-hunk)
    nmap <silent><space>k <Plug>(signify-prev-hunk)
endif

if s:bundle_tap('vim-gitgutter')
    nnoremap <silent><space>h :<C-u>GitGutterLineHighlightsToggle<CR>
    nnoremap <silent><space>j :<C-u>GitGutterNextHunk<CR>
    nnoremap <silent><space>k :<C-u>GitGutterPrevHunk<CR>
endif

if s:bundle_tap('neosnippet.vim')
    imap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    smap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    xmap <expr><C-k> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<C-G>U<C-o>D"
    let g:neosnippet#snippets_directory = '~/.vim/snippets/'
endif

if s:bundle_tap('unite-outline')
    nnoremap <silent> U :<C-u>Unite outline -vertical -direction=belowright<CR>
endif

if s:bundle_tap('tagbar')
    nnoremap <silent> T :<C-u>TagbarToggle<CR>
endif

if s:bundle_tap('vim-unite-giti')
    nnoremap <silent> <leader>s :<C-u>Unite giti/status<CR>
    nnoremap <silent> <leader>d :<C-u>Unite giti/log<CR>
endif

if s:bundle_tap('auto-ctags.vim')
    let g:auto_ctags = 0
    let g:auto_ctags_directory_list = ['.git']
endif

if s:bundle_tap('vim-choosewin')
    nmap `` <Plug>(choosewin)

    let g:choosewin_overlay_enable = 1
    let g:choosewin_overlay_clear_multibyte = 1
    let g:choosewin_statusline_replace = 0
    let g:choosewin_blink_on_land = 1
    let g:choosewin_return_on_single_win = 0
    let g:choosewin_color_overlay_current = {
        \ 'cterm': [9, 9],
        \ }
    let g:choosewin_color_overlay = {
        \ 'cterm': [7, 7],
        \ }
    let g:choosewin_color_label_current = {
        \ 'cterm': [7, 0]
        \ }
    let g:choosewin_color_label = {
        \ 'cterm': [0, 7]
        \ }
    let g:choosewin_color_other = {
        \ 'cterm': [0, 0]
        \ }
endif

if s:bundle_tap('vim-anzu')
    nmap * "zyiw:let @/ = @z<CR>:<C-u>set hlsearch<CR><Plug>(anzu-update-search-status)
    vmap * "zy:let @/ = @z<CR>:<C-u>set hlsearch<CR><Plug>(anzu-update-search-status)
    nmap <silent><Esc><Esc> <Plug>(anzu-clear-search-status):<C-u>nohlsearch<CR>
endif

if s:bundle_tap('vim-watchdogs')
    "æ›¸ãè¾¼ã¿å¾Œã«æ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†
    let g:watchdogs_check_BufWritePost_enable = 1

    "ä¸€å®šæ™‚é–“ã‚­ãƒ¼å…¥åŠ›ãŒãªã‹ã£ãŸå ´åˆã«æ§‹æ–‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†
    let g:watchdogs_check_CursorHold_enable = 1

    "falseã®ã¨ã:wqæ™‚ã«å®Ÿè¡Œã—ãªã„
    let g:watchdogs_check_BufWritePost_enable_on_wq = 0

    "vim-hierã§ã‚¨ãƒ©ãƒ¼ç®‡æ‰€ãŒãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚Œã‚‹ã®ã§:WathcdogsRunå¾Œã«quickfixã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è‡ªå‹•çš„ã«é–‰ã˜ã‚‹
    let g:quickrun_config['watchdogs_checker/_'] = {
        \ 'outputter/quickfix/open_cmd': '',
        \ 'hook/qfsigns_update/enable_exit': 1,
        \ 'hook/qfsigns_update/priority_exit': 3,
        \ }

    " phpcs
    let s:phpcs_command = 'phpcs'
    if executable(s:phpcs_command)
        let s:error_format =
            \ '%-GFile\,Line\,Column\,Type\,Message\,Source\,Severity%.%#,'.
            \ '"%f"\,%l\,%c\,%t%*[a-zA-Z]\,"%m"\,%*[a-zA-Z0-9_.-]\,%*[0-9]%.%#'

        let g:quickrun_config["watchdogs_checker/phpcs"] = {
            \ "quickfix/errorformat": s:error_format,
            \ "command" : s:phpcs_command,
            \ "cmdopt" : "--report=csv --standard=ruleset.xml",
            \ "exec" : '%c %o %s:p',
            \ }

        let g:quickrun_config["php/watchdogs_checker"] = {
            \ "type" : "watchdogs_checker/phpcs",
            \ }
    endif

    function! neobundle#hooks.on_source(bundle) abort
        call watchdogs#setup(g:quickrun_config)
    endfunction
endif


" Finish
" ------------------------------------------------------------------------------
" load .vimrc_local if file readable
if filereadable(expand('~/.vim/vimrc_local'))
    source ~/.vim/vimrc_local
endif

" end neobundle block
call s:bundle_end()

" enable syntax
syntax on
